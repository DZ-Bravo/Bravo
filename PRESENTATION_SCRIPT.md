# 아키텍처 발표 스크립트

## 🎯 발표 개요 (1분)

"안녕하세요. 오늘은 '오늘의 등산' 웹사이트 프로젝트의 클라우드 네이티브 아키텍처를 소개하겠습니다.

이 프로젝트는 React 프론트엔드와 Node.js 백엔드로 구성된 등산 정보 플랫폼으로, Kubernetes 기반의 마이크로서비스 아키텍처로 설계되었습니다.

주요 특징은 다음과 같습니다:
- 10개의 마이크로서비스
- Kubernetes 클러스터 운영
- Istio 서비스 메시
- 자동 스케일링 (HPA)
- 고가용성 데이터베이스 구성"

---

## 📊 전체 아키텍처 개요 (2-3분)

### 1. 전체 구조 설명

"먼저 전체 아키텍처를 보시면, 크게 3개 영역으로 나뉩니다:

**왼쪽: Kubernetes 클러스터**
- 온프레미스 Kubernetes 환경
- 여러 네임스페이스로 서비스 분리
- 마이크로서비스 아키텍처

**오른쪽: AWS 클라우드**
- 향후 마이그레이션 대상
- 클라우드 네이티브 서비스 활용

**상단: 사용자 접근**
- 사용자 요청
- 관리 도구 (kubectl, k6 등)"

### 2. 네임스페이스 구조

"Kubernetes 클러스터는 기능별로 네임스페이스를 분리했습니다:

1. **bravo-core-ns**: 핵심 애플리케이션 서비스
2. **bravo-front-ns**: 프론트엔드 서비스
3. **bravo-ai-integration-ns**: AI 관련 서비스
4. **bravo-mongo-ns**: MongoDB 데이터베이스
5. **bravo-redis-ns**: Redis 캐시
6. **bravo-efk-ns**: Elasticsearch, Kibana
7. **istio-system**: 서비스 메시
8. **cicd-ns**: CI/CD 도구 (Jenkins, Harbor)"

---

## 🔄 트래픽 흐름 설명 (3-4분)

### 1. 사용자 요청 흐름

"사용자 요청이 들어오는 흐름을 설명하겠습니다:

**1단계: 외부 진입**
```
사용자 → Istio Ingress Gateway (istio-system)
```
- 모든 외부 트래픽의 단일 진입점
- TLS 종료 및 라우팅
- 3개 Pod로 고가용성 구성

**2단계: 라우팅**
```
Istio Gateway → VirtualService → 각 서비스
```
- 경로 기반 라우팅
- 예: `/api/auth` → auth-service
- 예: `/api/posts` → community-service

**3단계: 서비스 처리**
```
각 마이크로서비스 → MongoDB/Redis/Elasticsearch
```
- 비즈니스 로직 처리
- 데이터베이스 조회
- 응답 반환"

### 2. 프론트엔드 요청

"프론트엔드 요청은:
```
사용자 → Istio Gateway → frontend-service (bravo-front-ns)
```
- React 앱이 Nginx로 서빙됨
- 정적 파일 제공
- API 호출은 백엔드로 프록시"

---

## 🏗️ 핵심 컴포넌트 상세 설명 (5-6분)

### 1. Core 네임스페이스 (bravo-core-ns)

"핵심 애플리케이션 서비스들을 보겠습니다:

**인증 서비스 (auth-service)**
- 회원가입, 로그인, JWT 토큰 발급
- 프로필 이미지 업로드 (PVC: auth-uploads-pvc)
- 리소스: CPU 100m/500m, Memory 256Mi/512Mi

**커뮤니티 서비스 (community-service)**
- 게시글 CRUD, 댓글, 좋아요
- 이미지 업로드 (PVC: community-uploads-pvc)
- Elasticsearch 통합 검색

**스토어 서비스 (store-service)**
- 상품 관리, 주문 처리
- Elasticsearch 상품 검색

**산 정보 서비스 (mountain-service)**
- 등산 코스 정보, GeoJSON 데이터
- 날씨 정보 연동
- 대용량 데이터 (PVC: mountain-data-pvc, 5Gi)

**공지사항, 일정, 알림 서비스**
- 각각 독립적인 마이크로서비스
- MongoDB 공유 사용"

**설계 포인트:**
- 각 서비스는 독립적으로 배포/스케일링 가능
- HPA로 자동 스케일링 (min 2, max 5)
- Node.js 기반으로 리소스 효율적 운영

### 2. AI 통합 네임스페이스 (bravo-ai-integration-ns)

"AI 관련 서비스들:

**AI 서비스 (ai-service)**
- AWS Bedrock 기반 등산 코스 추천
- 리소스: CPU 200m/1, Memory 512Mi/2Gi (더 많은 리소스 필요)

**AI 인프라 서비스 (ai-infra-service)**
- Kubernetes 클러스터 모니터링
- Prometheus, Loki 연동
- AI 분석 및 보고서 생성

**챗봇 서비스 (chatbot-service)**
- 사용자 문의 응답"

### 3. 데이터 계층

"**MongoDB (bravo-mongo-ns)**
- Primary-Secondary-Secondary 구성
- Replica Set으로 고가용성
- 각 Pod마다 3Gi PVC

**Redis (bravo-redis-ns)**
- 캐시 및 세션 저장
- Primary-Secondary-Sentinel 구성
- 1Gi PVC

**Elasticsearch (bravo-efk-ns)**
- 검색 엔진
- 산, 게시글, 상품 인덱싱
- Kibana로 관리
- 5Gi PVC"

### 4. 인프라 계층

"**Istio (istio-system)**
- 서비스 메시
- 트래픽 관리, 보안, 관찰성
- Ingress Gateway: 모든 트래픽 진입점

**CI/CD (cicd-ns)**
- Jenkins: 빌드/배포 자동화
- Harbor: 컨테이너 이미지 레지스트리
- SonarQube: 코드 품질 분석"

---

## 🎯 핵심 설계 결정사항 (3-4분)

### 1. 마이크로서비스 아키텍처

"왜 마이크로서비스를 선택했나요?

**장점:**
- 서비스별 독립 배포
- 기술 스택 다양화 가능
- 장애 격리
- 팀별 독립 개발

**구현:**
- 각 서비스는 독립적인 Deployment
- 공유 리소스(shared)로 코드 재사용
- 네임스페이스로 논리적 분리"

### 2. 리소스 관리 전략

"리소스 관리는 3단계로 구성했습니다:

**1. ResourceQuota: 네임스페이스별 제한**
- 예: bravo-core-ns = CPU 6, Memory 14Gi
- 리소스 남용 방지

**2. LimitRange: Pod별 기본값**
- 예: CPU 100m-1, Memory 128Mi-1Gi
- 일관된 리소스 설정

**3. HPA: 자동 스케일링**
- CPU 70% 타겟
- min 2, max 5 replicas
- 트래픽에 따라 자동 조정"

### 3. 고가용성 설계

"고가용성을 위해:

**서비스 레벨:**
- minReplicas 2-3개
- 여러 노드에 분산 배포
- Health check 및 자동 재시작

**데이터 레벨:**
- MongoDB Replica Set
- Redis Sentinel
- PVC로 데이터 영구 저장

**인프라 레벨:**
- Istio Gateway 3개 Pod
- 여러 워커 노드"

### 4. 보안 설계

"보안은 다층으로 구성:

**네트워크:**
- NetworkPolicy로 트래픽 제어
- 서비스 간 통신만 허용

**인증/인가:**
- JWT 토큰 기반
- Secret으로 민감 정보 관리

**서비스 메시:**
- Istio mTLS
- 서비스 간 암호화 통신"

---

## 📈 확장성 및 모니터링 (2-3분)

### 1. 자동 스케일링

"HPA로 자동 스케일링:

**스케일 업 조건:**
- CPU 70% 초과 시
- 60초 안정화 창
- 최대 2개 Pod 증가

**스케일 다운 조건:**
- CPU 70% 미만 시
- 5분 안정화 창
- 보수적 감소 (25%)"

### 2. 모니터링

"모니터링 스택:

**Prometheus:**
- 메트릭 수집
- CPU, Memory, 네트워크

**Grafana:**
- 대시보드 시각화
- 알람 설정

**Loki:**
- 로그 수집
- Fluent Bit 연동

**AI 인프라 서비스:**
- 통합 모니터링 대시보드
- AI 기반 분석"

---

## 🚀 향후 계획 (1-2분)

### 1. AWS 마이그레이션

"향후 AWS로 마이그레이션 계획:

**단계별 마이그레이션:**
1. EKS 클러스터 구축
2. 데이터베이스 마이그레이션 (DocumentDB, ElastiCache)
3. 애플리케이션 배포
4. 트래픽 점진적 전환

**예상 효과:**
- 관리형 서비스 활용
- 자동 스케일링 강화
- 비용 최적화"

### 2. 개선 사항

"지속적인 개선:
- 서비스 메시 고도화
- 모니터링 강화
- 보안 강화
- 성능 최적화"

---

## 💡 Q&A 대비

### 예상 질문 1: "왜 Istio를 사용했나요?"

**답변:**
"Istio를 선택한 이유는:
1. **서비스 메시 기능**: 트래픽 관리, 보안, 관찰성 통합 제공
2. **mTLS**: 서비스 간 자동 암호화
3. **트래픽 제어**: Canary 배포, A/B 테스트 지원
4. **관찰성**: 메트릭, 로그, 트레이싱 통합
5. **표준화**: CNCF 프로젝트로 업계 표준"

### 예상 질문 2: "리소스를 왜 이렇게 설정했나요?"

**답변:**
"각 서비스의 특성과 실제 사용 패턴을 분석해 설정했습니다:
- **Core 서비스**: Node.js 기반이라 CPU 100m, Memory 256Mi로 충분
- **AI 서비스**: AI 작업 특성상 더 많은 리소스 필요 (CPU 200m/1, Memory 512Mi/2Gi)
- **Frontend**: 정적 파일 서빙이라 더 작게 (CPU 100m, Memory 128Mi)
- **HPA와 연동**: Limits 기준으로 70% 타겟 설정"

### 예상 질문 3: "마이크로서비스의 단점은?"

**답변:**
"마이크로서비스의 단점도 인지하고 있습니다:
1. **복잡성 증가**: 운영 복잡도 상승
2. **네트워크 지연**: 서비스 간 통신 오버헤드
3. **데이터 일관성**: 분산 트랜잭션 관리 어려움

**대응 방안:**
- Istio로 서비스 메시 통합 관리
- MongoDB Replica Set으로 데이터 일관성
- 모니터링 강화로 문제 조기 발견"

### 예상 질문 4: "비용은 어떻게 관리하나요?"

**답변:**
"비용 관리를 위해:
1. **ResourceQuota**: 네임스페이스별 리소스 제한
2. **HPA**: 필요할 때만 스케일링
3. **모니터링**: 리소스 사용량 추적
4. **최적화**: 불필요한 리소스 정리

현재 워커 노드 22 CPU, 30Gi Memory 중 약 12.3 CPU, 17Gi 사용 중입니다."

---

## 🎬 마무리 (1분)

"정리하면, 이 아키텍처는:

1. **확장 가능**: HPA로 자동 스케일링
2. **고가용성**: 다중 Pod, Replica Set
3. **관리 용이**: 네임스페이스 분리, 모니터링
4. **보안**: NetworkPolicy, mTLS
5. **클라우드 네이티브**: Kubernetes, 컨테이너 기반

향후 AWS 마이그레이션을 통해 더욱 안정적이고 확장 가능한 시스템으로 발전시킬 계획입니다.

감사합니다. 질문 있으시면 말씀해 주세요."

---

## 📝 발표 팁

### 1. 시간 배분 (총 15-20분)
- 오프닝: 1분
- 전체 개요: 2-3분
- 트래픽 흐름: 3-4분
- 핵심 컴포넌트: 5-6분
- 설계 결정사항: 3-4분
- 확장성/모니터링: 2-3분
- 향후 계획: 1-2분
- Q&A: 5-10분

### 2. 다이어그램 설명 순서
1. 전체 구조 (왼쪽 → 오른쪽)
2. 트래픽 흐름 (위 → 아래)
3. 네임스페이스별 상세
4. 데이터 흐름
5. 보안 및 네트워크

### 3. 강조할 포인트
- ✅ 실제 운영 중인 시스템
- ✅ 마이크로서비스 아키텍처
- ✅ 자동화 (HPA, CI/CD)
- ✅ 고가용성 설계
- ✅ 모니터링 및 관찰성

### 4. 피해야 할 표현
- ❌ "이론적으로는..."
- ❌ "아직 구현 안 됐지만..."
- ✅ "실제로 운영 중입니다"
- ✅ "모니터링 데이터 기준으로..."

---

**작성일**: 2024-12-25  
**버전**: 1.0

